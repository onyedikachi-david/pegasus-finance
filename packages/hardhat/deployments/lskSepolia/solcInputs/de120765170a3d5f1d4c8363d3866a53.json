{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n  using SafeMath for uint256;\n\n  error GetDataServiceIdNotImplemented();\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return dataServiceId which DataServiceWrapper will use if not provided explicitly .\n   * If not overridden, value will always have to be provided explicitly in DataServiceWrapper.\n   * @return dataServiceId being consumed by contract\n   */\n  function getDataServiceId() public view virtual returns (string memory) {\n    revert GetDataServiceIdNotImplemented();\n  }\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overridden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. too old timestamp or\n   * insufficient number of authorised signers) do not match, the function will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   */\n  function _securelyExtractOracleValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length; i++) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageByteSize = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n      calldataNegativeOffset += dataPackageByteSize;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return An array of the aggregated values\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      uint48 extractedTimestamp;\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n\n      signedMessageBytesCount = dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n      uint256 timestampCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      // Validating timestamp\n      validateTimestamp(extractedTimestamp);\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize,\n          dataPointIndex\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n          dataFeedIdIndex++\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][\n                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n              ] = dataPointValue;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n        }\n      }\n    }\n\n    // Return total data package byte size\n    return\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS +\n      (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) *\n      dataPointsCount;\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    uint256[] memory valuesWithoutDuplicates = getOracleNumericValuesFromTxMsg(dataFeedIdsWithoutDuplicates);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/MainDemoConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract MainDemoConsumerBase is RedstoneConsumerNumericBase {\n  function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-main-demo\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) {\n      return 0;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "contracts/dependencies/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * Based on OpenZeppelin's Ownable contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n *\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\n     * NOTE: This function is not safe, as it doesnâ€™t check owner is calling it.\n     * Make sure you check it before calling it.\n     */\n    function _renounceOwnership() internal {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IERC20WithPermit {\n    // -- Events --\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // -- Functions --\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function mint(address to, uint value) external;\n\n    function burn(address from, uint value) external;\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IPriceFeed {\n\t// -- Events --\n\tevent UpdatePrice(uint128 updatedAt, uint128 price);\n\n\t// -- Functions --\n\tfunction getPrice() external view returns (uint256);\n\n\tfunction getScale() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"../libraries/PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n\t/// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n\tfunction getValidTimePeriod() external view returns (uint validTimePeriod);\n\n\t/// @notice Returns the price and confidence interval.\n\t/// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n\t/// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getPrice(\n\t\tbytes32 id\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Returns the exponentially-weighted moving average price and confidence interval.\n\t/// @dev Reverts if the EMA price is not available.\n\t/// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getEmaPrice(\n\t\tbytes32 id\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Returns the price of a price feed without any sanity checks.\n\t/// @dev This function returns the most recent price update in this contract without any recency checks.\n\t/// This function is unsafe as the returned price update may be arbitrarily far in the past.\n\t///\n\t/// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n\t/// sufficiently recent for their application. If you are considering using this function, it may be\n\t/// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getPriceUnsafe(\n\t\tbytes32 id\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Returns the price that is no older than `age` seconds of the current time.\n\t/// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n\t/// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n\t/// recently.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getPriceNoOlderThan(\n\t\tbytes32 id,\n\t\tuint age\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n\t/// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n\t/// However, if the price is not recent this function returns the latest available price.\n\t///\n\t/// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n\t/// the returned price is recent or useful for any particular application.\n\t///\n\t/// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n\t/// sufficiently recent for their application. If you are considering using this function, it may be\n\t/// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getEmaPriceUnsafe(\n\t\tbytes32 id\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n\t/// of the current time.\n\t/// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n\t/// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n\t/// recently.\n\t/// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n\tfunction getEmaPriceNoOlderThan(\n\t\tbytes32 id,\n\t\tuint age\n\t) external view returns (PythStructs.Price memory price);\n\n\t/// @notice Update price feeds with given update messages.\n\t/// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n\t/// `getUpdateFee` with the length of the `updateData` array.\n\t/// Prices will be updated if they are more recent than the current stored prices.\n\t/// The call will succeed even if the update is not the most recent.\n\t/// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n\t/// @param updateData Array of price update data.\n\tfunction updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n\t/// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n\t/// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n\t/// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n\t///\n\t/// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n\t/// `getUpdateFee` with the length of the `updateData` array.\n\t///\n\t/// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n\t/// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n\t/// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n\t/// Otherwise, it calls updatePriceFeeds method to update the prices.\n\t///\n\t/// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n\t/// @param updateData Array of price update data.\n\t/// @param priceIds Array of price ids.\n\t/// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n\tfunction updatePriceFeedsIfNecessary(\n\t\tbytes[] calldata updateData,\n\t\tbytes32[] calldata priceIds,\n\t\tuint64[] calldata publishTimes\n\t) external payable;\n\n\t/// @notice Returns the required fee to update an array of price updates.\n\t/// @param updateData Array of price update data.\n\t/// @return feeAmount The required fee in Wei.\n\tfunction getUpdateFee(\n\t\tbytes[] calldata updateData\n\t) external view returns (uint feeAmount);\n\n\t/// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n\t/// within `minPublishTime` and `maxPublishTime`.\n\t///\n\t/// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n\t/// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n\t/// are more recent than the current stored prices.\n\t///\n\t/// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n\t/// `getUpdateFee` with the length of the `updateData` array.\n\t///\n\t///\n\t/// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n\t/// no update for any of the given `priceIds` within the given time range.\n\t/// @param updateData Array of price update data.\n\t/// @param priceIds Array of price ids.\n\t/// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n\t/// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n\t/// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n\tfunction parsePriceFeedUpdates(\n\t\tbytes[] calldata updateData,\n\t\tbytes32[] calldata priceIds,\n\t\tuint64 minPublishTime,\n\t\tuint64 maxPublishTime\n\t) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n\t/// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n\t/// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n\t/// this method will return the first update. This method may store the price updates on-chain, if they\n\t/// are more recent than the current stored prices.\n\t///\n\t///\n\t/// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n\t/// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n\t/// @param updateData Array of price update data.\n\t/// @param priceIds Array of price ids.\n\t/// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n\t/// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n\t/// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n\tfunction parsePriceFeedUpdatesUnique(\n\t\tbytes[] calldata updateData,\n\t\tbytes32[] calldata priceIds,\n\t\tuint64 minPublishTime,\n\t\tuint64 maxPublishTime\n\t) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "contracts/interfaces/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n\t/// @dev Emitted when the price feed with `id` has received a fresh update.\n\t/// @param id The Pyth Price Feed ID.\n\t/// @param publishTime Publish time of the given price update.\n\t/// @param price Price of the given price update.\n\t/// @param conf Confidence interval of the given price update.\n\tevent PriceFeedUpdate(\n\t\tbytes32 indexed id,\n\t\tuint64 publishTime,\n\t\tint64 price,\n\t\tuint64 conf\n\t);\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IVaultManager {\n    // --- Events ---\n    event CreateVault(address indexed owner, uint vaultId, uint128 coll, uint128 dri, uint128 cri);\n    event IncreaseVaultColl(address indexed owner, uint vaultId, uint128 coll, uint128 dri, uint128 cri);\n    event DecreaseVaultColl(address indexed owner, uint vaultId, uint128 coll, uint128 dri, uint128 cri);\n    event IncreaseVaultDebt(address indexed owner, uint vaultId, uint128 debt, uint128 dri, uint128 cri);\n    event DecreaseVaultDebt(address indexed owner, uint vaultId, uint128 debt, uint128 dri, uint128 cri);\n    event Liquidate(address indexed liquidator, address indexed owner, uint vaultId);\n    event Redeem(address indexed redeemer, uint debt, uint coll);\n\n    function createVault(uint128 initialColl) external payable;\n\n    function increaseVaultColl(uint vaultId, uint128 collIncrease) external payable;\n\n    function decreaseVaultColl(uint vaultId, uint128 collDecrease) external;\n\n    function increaseVaultDebt(uint vaultId, uint128 debtIncrease) external;\n\n    function decreaseVaultDebt(uint vaultId, uint128 debtDecrease) external;\n\n    function liquidate(address owner, uint vaultId) external;\n\n    function redeem(uint debtToRedeem) external;\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./FixedPoint.sol\";\n\nlibrary Constants {\n    uint internal constant BORROW_FEE_BPS = 500;\n\n    uint internal constant BASE_MCR = 105 * FixedPoint.Q64;\n\n    uint internal constant MAX_REDEMPTION_D_RATIO_BUMP = 500 * FixedPoint.Q64;\n\n    uint internal constant CONTINUOUS_D_RATIO_DECAY = 10;\n\n    uint internal constant SECONDS_IN_A_YEAR = 86400 * 365;\n    uint internal constant SECONDS_IN_A_DAY = 86400;\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\nlibrary Errors {\n    string constant NOT_AUTHORISED = \"0\";\n    string constant INVALID_ETH_AMOUNT = \"1\";\n    string constant UNDER_COLLATERALISED_VAULT = \"2\";\n    string constant DEADLINE_CROSSED = \"3\";\n    string constant INVALID_SIGNATURE = \"4\";\n    string constant FAILED_ETH_TRANSFER = \"5\";\n    string constant VAULT_IS_INACTIVE = \"6\";\n    string constant VAULT_IS_NOT_UNDERCOLLATERALISED = \"7\";\n    string constant VAULT_IS_ACTIVE = \"8\";\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nlibrary FixedPoint {\n    uint128 internal constant Q64 = 0x10000000000000000;\n    uint internal constant Q64_MUL_100 = 100 * Q64;\n}\n"
    },
    "contracts/libraries/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n\t// A price with a degree of uncertainty, represented as a price +- a confidence interval.\n\t//\n\t// The confidence interval roughly corresponds to the standard error of a normal distribution.\n\t// Both the price and confidence are stored in a fixed-point numeric representation,\n\t// `x * (10^expo)`, where `expo` is the exponent.\n\t//\n\t// Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n\t// to how this price safely.\n\tstruct Price {\n\t\t// Price\n\t\tint64 price;\n\t\t// Confidence interval around the price\n\t\tuint64 conf;\n\t\t// Price exponent\n\t\tint32 expo;\n\t\t// Unix timestamp describing when the price was published\n\t\tuint publishTime;\n\t}\n\n\t// PriceFeed represents a current aggregate price from pyth publisher feeds.\n\tstruct PriceFeed {\n\t\t// The price ID.\n\t\tbytes32 id;\n\t\t// Latest available price\n\t\tPrice price;\n\t\t// Latest available exponentially-weighted moving average price\n\t\tPrice emaPrice;\n\t}\n}\n"
    },
    "contracts/libraries/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./FixedPoint.sol\";\n\nlibrary Vault {\n    struct State {\n        uint128 debt;\n        uint128 collateral;\n        uint128 lastDebtRebaseIndex;\n        uint128 lastCollRebaseIndex;\n        bool isActive;\n    }\n\n    function computeKey(address addr, uint id) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(addr, id));\n    }\n\n    function get(\n        mapping(bytes32 => State) storage self,\n        address owner,\n        uint vaultId\n    ) internal view returns (State storage vault) {\n        return self[computeKey(owner, vaultId)];\n    }\n\n    function insert(mapping(bytes32 => State) storage self, address owner, uint vaultId, State memory vault) internal {\n        self[computeKey(owner, vaultId)] = vault;\n    }\n\n    function update(mapping(bytes32 => State) storage self, address owner, uint vaultId, State memory vault) internal {\n        self[computeKey(owner, vaultId)] = vault;\n    }\n}\n"
    },
    "contracts/PegasusUSD.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./libraries/Errors.sol\";\nimport \"./dependencies/Ownable.sol\";\nimport \"./interfaces/IERC20WithPermit.sol\";\n\ncontract PegasusUSD is IERC20WithPermit, Ownable {\n\tstring public constant name = \"Pegasus Stablecoin\";\n\tstring public constant symbol = \"pUSD\";\n\tuint8 public constant decimals = 18;\n\n\taddress internal minter;\n\n\tuint public totalSupply;\n\tmapping(address => uint) public balanceOf;\n\tmapping(address => mapping(address => uint)) public allowance;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\t0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\tmapping(address => uint) public nonces;\n\n\tconstructor() {\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256(\n\t\t\t\t\t\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\t\t\t\t),\n\t\t\t\tkeccak256(bytes(name)),\n\t\t\t\tkeccak256(bytes(\"1\")),\n\t\t\t\tblock.chainid,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t\tminter = msg.sender;\n\t}\n\n\tmodifier onlyMinter() {\n\t\trequire(msg.sender == minter, Errors.NOT_AUTHORISED);\n\t\t_;\n\t}\n\n\tfunction updateMinter(address newMinter) external onlyOwner {\n\t\tminter = newMinter;\n\t}\n\n\tfunction mint(address to, uint value) external onlyMinter {\n\t\ttotalSupply = totalSupply + value;\n\t\tbalanceOf[to] = balanceOf[to] + value;\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\tfunction burn(address from, uint value) external onlyMinter {\n\t\tbalanceOf[from] = balanceOf[from] - value;\n\t\ttotalSupply = totalSupply - value;\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\tfunction _approve(address owner, address spender, uint value) private {\n\t\tallowance[owner][spender] = value;\n\t\temit Approval(owner, spender, value);\n\t}\n\n\tfunction _transfer(address from, address to, uint value) private {\n\t\tbalanceOf[from] = balanceOf[from] - value;\n\t\tbalanceOf[to] = balanceOf[to] + value;\n\t\temit Transfer(from, to, value);\n\t}\n\n\tfunction approve(address spender, uint value) external returns (bool) {\n\t\t_approve(msg.sender, spender, value);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address to, uint value) external returns (bool) {\n\t\t_transfer(msg.sender, to, value);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint value\n\t) external returns (bool) {\n\t\tif (allowance[from][msg.sender] != type(uint256).max) {\n\t\t\tallowance[from][msg.sender] = allowance[from][msg.sender] - value;\n\t\t}\n\t\t_transfer(from, to, value);\n\t\treturn true;\n\t}\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint value,\n\t\tuint deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(deadline >= block.timestamp, Errors.DEADLINE_CROSSED);\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tPERMIT_TYPEHASH,\n\t\t\t\t\t\towner,\n\t\t\t\t\t\tspender,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tnonces[owner]++,\n\t\t\t\t\t\tdeadline\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\t\trequire(\n\t\t\trecoveredAddress != address(0) && recoveredAddress == owner,\n\t\t\tErrors.INVALID_SIGNATURE\n\t\t);\n\t\t_approve(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./dependencies/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"@redstone-finance/evm-connector/contracts/data-services/MainDemoConsumerBase.sol\";\n\ncontract PriceFeed is Ownable, IPriceFeed, MainDemoConsumerBase {\n\tuint constant SCALE = 8;\n\n\tfunction getPrice() external view returns (uint256) {\n\t\treturn getOracleNumericValueFromTxMsg(\"LSK\");\n\t}\n\n\tfunction getScale() external pure returns (uint) {\n\t\treturn SCALE;\n\t}\n}\n"
    },
    "contracts/VaultManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./PegasusUSD.sol\";\nimport \"./libraries/Vault.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/FixedPoint.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPyth.sol\";\nimport \"./interfaces/IVaultManager.sol\";\n\ncontract VaultManager is IVaultManager {\n\tusing Vault for mapping(bytes32 => Vault.State);\n\tusing Vault for Vault.State;\n\n\tstruct RebaseIndices {\n\t\tuint128 debtRebaseIndex;\n\t\tuint128 collRebaseIndex;\n\t\tuint lastUpdate;\n\t}\n\n\tstruct MinimumCollRatio {\n\t\tuint96 ratio;\n\t\tuint96 dRatio;\n\t\tuint64 lastUpdate;\n\t}\n\n\tRebaseIndices public rebaseIndices;\n\tMinimumCollRatio public minimumCollRatio;\n\n\tuint public lastVaultId;\n\tuint public collLocked;\n\n\tIPriceFeed internal pricefeed;\n\tPegasusUSD internal pegasusUSD;\n\tIPyth internal pyth;\n\tuint128 price;\n\n\tmapping(bytes32 => Vault.State) public vaults;\n\n\tconstructor() {\n\t\trebaseIndices = RebaseIndices(\n\t\t\tFixedPoint.Q64,\n\t\t\tFixedPoint.Q64,\n\t\t\tblock.timestamp\n\t\t);\n\t\tminimumCollRatio = MinimumCollRatio(\n\t\t\tuint96(Constants.BASE_MCR),\n\t\t\t0,\n\t\t\tuint64(block.timestamp)\n\t\t);\n\t}\n\n\tfunction initialize(address _pricefeed) external {\n\t\trequire(address(pegasusUSD) == address(0), Errors.NOT_AUTHORISED);\n\t\tpricefeed = IPriceFeed(_pricefeed);\n\t\tpegasusUSD = new PegasusUSD();\n\t}\n\n\tfunction _computeFeeDeductedDebtIndex(\n\t\tuint128 debtRebaseIndex,\n\t\tuint lastUpdate\n\t) private view returns (uint128) {\n\t\tuint denom = Constants.SECONDS_IN_A_YEAR * 10000;\n\t\tuint timePassed = block.timestamp - lastUpdate;\n\t\treturn\n\t\t\tuint128(\n\t\t\t\t(debtRebaseIndex *\n\t\t\t\t\t(denom - timePassed * Constants.BORROW_FEE_BPS)) / denom\n\t\t\t);\n\t}\n\n\tfunction _updateRebaseIndices() private returns (RebaseIndices memory) {\n\t\tRebaseIndices memory _rebaseIndices = rebaseIndices;\n\n\t\t_rebaseIndices.debtRebaseIndex = _computeFeeDeductedDebtIndex(\n\t\t\t_rebaseIndices.debtRebaseIndex,\n\t\t\t_rebaseIndices.lastUpdate\n\t\t);\n\t\t_rebaseIndices.lastUpdate = block.timestamp;\n\n\t\trebaseIndices = _rebaseIndices;\n\t\treturn _rebaseIndices;\n\t}\n\n\tfunction _isUnderCollateralised(\n\t\tVault.State memory vault,\n\t\tuint mcr,\n\t\tuint price,\n\t\tuint scale\n\t) private pure returns (bool) {\n\t\tuint lhs = vault.collateral * price * FixedPoint.Q64_MUL_100;\n\t\tuint rhs = mcr * vault.debt * scale;\n\t\treturn lhs < rhs;\n\t}\n\n\tfunction _touchMCR() private returns (uint) {\n\t\tMinimumCollRatio memory _minimumCollRatio = minimumCollRatio;\n\n\t\tuint timePassed = block.timestamp - minimumCollRatio.lastUpdate;\n\t\tuint _denom = Constants.SECONDS_IN_A_DAY * 10000;\n\t\tuint denom = _denom * FixedPoint.Q64;\n\n\t\tuint updatedRatio = (_minimumCollRatio.ratio *\n\t\t\t(denom + timePassed * _minimumCollRatio.dRatio)) / denom;\n\t\tuint updatedDRatio = (_minimumCollRatio.dRatio *\n\t\t\t(_denom - timePassed * Constants.CONTINUOUS_D_RATIO_DECAY)) /\n\t\t\t_denom;\n\n\t\tminimumCollRatio = MinimumCollRatio(\n\t\t\tuint96(updatedRatio),\n\t\t\tuint96(updatedDRatio),\n\t\t\tuint64(block.timestamp)\n\t\t);\n\t\treturn updatedRatio;\n\t}\n\n\tfunction _touchVault(\n\t\tVault.State memory vault\n\t) private returns (Vault.State memory) {\n\t\trequire(vault.isActive, Errors.VAULT_IS_INACTIVE);\n\n\t\tRebaseIndices memory _rebaseIndices = _updateRebaseIndices();\n\n\t\tunchecked {\n\t\t\tvault.debt =\n\t\t\t\t(vault.debt * vault.lastDebtRebaseIndex) /\n\t\t\t\t_rebaseIndices.debtRebaseIndex;\n\t\t\tvault.collateral =\n\t\t\t\t(vault.collateral * vault.lastCollRebaseIndex) /\n\t\t\t\t_rebaseIndices.collRebaseIndex;\n\n\t\t\tvault.lastCollRebaseIndex = _rebaseIndices.collRebaseIndex;\n\t\t\tvault.lastDebtRebaseIndex = _rebaseIndices.debtRebaseIndex;\n\t\t}\n\n\t\treturn vault;\n\t}\n\n\tfunction createVault(uint128 initialColl) external payable {\n\t\trequire(msg.value == initialColl, Errors.INVALID_ETH_AMOUNT);\n\n\t\tRebaseIndices memory _rebaseIndices = _updateRebaseIndices();\n\n\t\tVault.State memory _vault = Vault.State({\n\t\t\tisActive: true,\n\t\t\tdebt: 0,\n\t\t\tcollateral: initialColl,\n\t\t\tlastDebtRebaseIndex: _rebaseIndices.debtRebaseIndex,\n\t\t\tlastCollRebaseIndex: _rebaseIndices.collRebaseIndex\n\t\t});\n\n\t\tuint _vaultId = lastVaultId + 1;\n\t\tvaults.insert(msg.sender, _vaultId, _vault);\n\n\t\tlastVaultId = _vaultId;\n\t\tcollLocked += msg.value;\n\n\t\temit CreateVault(\n\t\t\tmsg.sender,\n\t\t\t_vaultId,\n\t\t\tinitialColl,\n\t\t\t_rebaseIndices.debtRebaseIndex,\n\t\t\t_rebaseIndices.collRebaseIndex\n\t\t);\n\t}\n\n\tfunction increaseVaultColl(\n\t\tuint vaultId,\n\t\tuint128 collIncrease\n\t) external payable {\n\t\trequire(msg.value == collIncrease, Errors.INVALID_ETH_AMOUNT);\n\n\t\tVault.State memory vault = _touchVault(vaults.get(msg.sender, vaultId));\n\t\tvault.collateral += collIncrease;\n\n\t\tcollLocked += collIncrease;\n\t\tvaults.update(msg.sender, vaultId, vault);\n\n\t\temit IncreaseVaultColl(\n\t\t\tmsg.sender,\n\t\t\tvaultId,\n\t\t\tcollIncrease,\n\t\t\tvault.lastDebtRebaseIndex,\n\t\t\tvault.lastCollRebaseIndex\n\t\t);\n\t}\n\n\tfunction decreaseVaultColl(uint vaultId, uint128 collDecrease) external {\n\t\tuint updatedMCR = _touchMCR();\n\t\tVault.State memory vault = _touchVault(vaults.get(msg.sender, vaultId));\n\t\tvault.collateral -= collDecrease;\n\n\t\trequire(\n\t\t\t!_isUnderCollateralised(\n\t\t\t\tvault,\n\t\t\t\tupdatedMCR,\n\t\t\t\tpricefeed.getPrice(),\n\t\t\t\tpricefeed.getScale()\n\t\t\t)\n\t\t);\n\n\t\tcollLocked -= collDecrease;\n\t\tvaults.update(msg.sender, vaultId, vault);\n\n\t\temit DecreaseVaultColl(\n\t\t\tmsg.sender,\n\t\t\tvaultId,\n\t\t\tcollDecrease,\n\t\t\tvault.lastDebtRebaseIndex,\n\t\t\tvault.lastCollRebaseIndex\n\t\t);\n\n\t\t(bool sent, ) = (msg.sender).call{ value: collDecrease }(\"\");\n\t\trequire(sent, Errors.FAILED_ETH_TRANSFER);\n\t}\n\n\tfunction increaseVaultDebt(uint vaultId, uint128 debtIncrease) external {\n\t\tuint updatedMCR = _touchMCR();\n\t\tVault.State memory vault = _touchVault(vaults.get(msg.sender, vaultId));\n\t\tvault.debt += debtIncrease;\n\n\t\trequire(\n\t\t\t!_isUnderCollateralised(\n\t\t\t\tvault,\n\t\t\t\tupdatedMCR,\n\t\t\t\tpricefeed.getPrice(),\n\t\t\t\tpricefeed.getScale()\n\t\t\t)\n\t\t);\n\t\tvaults.update(msg.sender, vaultId, vault);\n\n\t\temit IncreaseVaultDebt(\n\t\t\tmsg.sender,\n\t\t\tvaultId,\n\t\t\tdebtIncrease,\n\t\t\tvault.lastDebtRebaseIndex,\n\t\t\tvault.lastCollRebaseIndex\n\t\t);\n\n\t\tpegasusUSD.mint(msg.sender, debtIncrease);\n\t}\n\n\tfunction decreaseVaultDebt(uint vaultId, uint128 debtDecrease) external {\n\t\tVault.State memory vault = _touchVault(vaults.get(msg.sender, vaultId));\n\n\t\tvault.debt -= debtDecrease;\n\t\tvaults.update(msg.sender, vaultId, vault);\n\n\t\temit DecreaseVaultDebt(\n\t\t\tmsg.sender,\n\t\t\tvaultId,\n\t\t\tdebtDecrease,\n\t\t\tvault.lastDebtRebaseIndex,\n\t\t\tvault.lastCollRebaseIndex\n\t\t);\n\n\t\tpegasusUSD.burn(msg.sender, debtDecrease);\n\t}\n\n\tfunction liquidate(address owner, uint vaultId) external {\n\t\tuint updatedMCR = _touchMCR();\n\t\tVault.State memory vault = _touchVault(vaults.get(owner, vaultId));\n\n\t\trequire(\n\t\t\t_isUnderCollateralised(\n\t\t\t\tvault,\n\t\t\t\tupdatedMCR,\n\t\t\t\tpricefeed.getPrice(),\n\t\t\t\tpricefeed.getScale()\n\t\t\t),\n\t\t\tErrors.VAULT_IS_NOT_UNDERCOLLATERALISED\n\t\t);\n\t\tvault.isActive = false;\n\n\t\tcollLocked -= vault.collateral;\n\t\tvaults.update(owner, vaultId, vault);\n\n\t\temit Liquidate(msg.sender, owner, vaultId);\n\n\t\tpegasusUSD.burn(msg.sender, vault.debt);\n\n\t\t(bool sent, ) = (msg.sender).call{ value: vault.collateral }(\"\");\n\t\trequire(sent, Errors.FAILED_ETH_TRANSFER);\n\t}\n\n\tfunction redeem(uint debtToRedeem) external {\n\t\t(uint price, uint scale) = (pricefeed.getPrice(), pricefeed.getScale());\n\t\tuint collAmount = (debtToRedeem * scale) / price;\n\n\t\tRebaseIndices memory _rebaseIndices = rebaseIndices;\n\t\t_rebaseIndices.debtRebaseIndex = _computeFeeDeductedDebtIndex(\n\t\t\t_rebaseIndices.debtRebaseIndex,\n\t\t\t_rebaseIndices.lastUpdate\n\t\t);\n\n\t\tuint debtSupply = pegasusUSD.totalSupply();\n\t\tuint _collLocked = collLocked;\n\n\t\tuint updatedDebt = debtSupply - debtToRedeem;\n\t\tuint updatedColl = _collLocked - collAmount;\n\n\t\t_rebaseIndices.debtRebaseIndex = uint128(\n\t\t\t(debtSupply * _rebaseIndices.debtRebaseIndex) / updatedDebt\n\t\t);\n\t\t_rebaseIndices.collRebaseIndex = uint128(\n\t\t\t(collLocked * _rebaseIndices.collRebaseIndex) / updatedColl\n\t\t);\n\n\t\tuint denom = debtSupply * 10000;\n\t\tuint _leftOp = denom * minimumCollRatio.dRatio;\n\t\tuint _rightOP = Constants.MAX_REDEMPTION_D_RATIO_BUMP * debtToRedeem;\n\n\t\tminimumCollRatio.dRatio += uint96((_leftOp + _rightOP) / denom);\n\t\trebaseIndices = _rebaseIndices;\n\n\t\temit Redeem(msg.sender, debtToRedeem, collAmount);\n\n\t\tpegasusUSD.burn(msg.sender, debtToRedeem);\n\n\t\t(bool sent, ) = (msg.sender).call{ value: collAmount }(\"\");\n\t\trequire(sent, Errors.FAILED_ETH_TRANSFER);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}